[@testing-concepts](../../background/testing-concepts.md)

[@Pairing specification](Pairing.md)

[@Pairing implementation](/src/concepts/Pairing/PairingConcept.ts)

# test: Pairing

Please create comprehensive tests for the Pairing concept following these requirements:

## Required Tests:

### 1. Operational Principle Test (1 test)
Test the common expected usage:
- User1 generates a pairing code
- User2 accepts the code
- They become paired
- Verify both users are paired
- Either user can dissolve the pair

### 2. Additional Scenarios (3-5 tests)

**Test: generateCode requirements**
- User cannot generate multiple codes
- User already paired cannot generate code
- Code generation returns unique codes

**Test: acceptPairing requirements**
- Cannot accept own code
- Cannot accept invalid/used code
- Already paired user cannot accept new code
- Generator already paired prevents acceptance

**Test: dissolvePair functionality**
- Can dissolve active pair
- Cannot dissolve non-existent pair
- Cannot dissolve already dissolved pair

**Test: getPair and isPaired queries**
- getPair returns correct pair for user
- isPaired returns true/false correctly
- Error when user not paired

**Test: Edge cases and race conditions**
- Two users try to accept same code
- User generates code, gets paired by someone else, then tries to accept another code

## Requirements:
- Use Deno testing framework
- Print helpful console messages showing inputs/outputs
- Use assertions (assertEquals, assertRejects, etc.)
- Each test should setup and teardown using unique database names
- Tests should be self-contained (no shared state)
- Include both success and error cases

The test file should be at: `src/concepts/Pairing/PairingConcept.test.ts`


# response:

To provide comprehensive testing for the `Pairing` concept, the following test file adheres to the specified requirements:

*   Uses the `Deno.test` framework with nested `t.step` for clear organization.
*   Each test step that manipulates or queries the database creates a new `PairingConcept` instance and closes the database client using `testDb` to ensure isolation.
*   Detailed `log` messages output the test's intent, inputs, and results, aiding in debugging and understanding.
*   Assertions (`assertEquals`, `assertNotEquals`, `assertExists`) are used to verify outcomes, including both success and error conditions.

```typescript
// file: src/concepts/Pairing/PairingConcept.test.ts
import { testDb } from "@utils/database.ts"; // Utility to get a clean database instance
import { assertEquals, assertNotEquals, assertExists } from "jsr:@std/assert";
import PairingConcept from "./PairingConcept.ts"; // The concept implementation
import { ID, Empty } from "@utils/types.ts"; // Assuming ID and Empty types are defined

// Helper function for consistent logging
function log(title: string, data?: any) {
  console.log(`\n--- ${title} ---`);
  if (data !== undefined) {
    console.log(JSON.stringify(data, null, 2));
  }
}

Deno.test("Pairing Concept - Comprehensive Tests", async (t) => {
  // Common user IDs for tests
  const user1: ID = "user-alice";
  const user2: ID = "user-bob";
  const user3: ID = "user-charlie";
  const user4: ID = "user-diana";

  // # trace: Principle Test - Users can successfully pair and unpair
  // This test demonstrates the core functionality as described in the concept's principle.
  await t.step("Principle: Users can successfully pair and unpair", async () => {
    log("Starting Principle Test: User pairing and unpairing flow.");

    const [db, client] = await testDb();
    const pairing = new PairingConcept(db);

    try {
      // 1. User1 (Alice) generates a pairing code
      log("Step 1: User1 (Alice) generates a pairing code.");
      const generateResult = await pairing.generateCode({ user: user1 });
      assertExists((generateResult as { code: ID }).code, "generateCode should return a code.");
      const code1 = (generateResult as { code: ID }).code;
      log("  -> Code generated by Alice:", { code: code1 });

      // Verify User1 is not yet paired (only has a pending code)
      const isUser1PairedBeforeAccept = await pairing.isPaired({ user: user1 });
      assertEquals(isUser1PairedBeforeAccept, false, "User1 should not be paired yet after generating code.");
      log("  -> Verified: User1 is not yet in an active pair.");

      // Verify User2 is not paired
      const isUser2PairedBeforeAccept = await pairing.isPaired({ user: user2 });
      assertEquals(isUser2PairedBeforeAccept, false, "User2 should not be paired yet.");

      // 2. User2 (Bob) accepts the code
      log("Step 2: User2 (Bob) accepts the pairing code from Alice.");
      const acceptResult = await pairing.acceptPairing({ user: user2, code: code1 });
      assertExists((acceptResult as { pair: ID }).pair, "acceptPairing should return a pair ID.");
      const pairId = (acceptResult as { pair: ID }).pair;
      log("  -> Pair created with ID:", { pair: pairId });

      // 3. Verify both users are now paired
      log("Step 3: Verifying both users are now paired.");
      const isUser1PairedAfterAccept = await pairing.isPaired({ user: user1 });
      assertEquals(isUser1PairedAfterAccept, true, "User1 should be paired after acceptance.");
      log("  -> Verified: User1 (Alice) is paired.");

      const isUser2PairedAfterAccept = await pairing.isPaired({ user: user2 });
      assertEquals(isUser2PairedAfterAccept, true, "User2 should be paired after acceptance.");
      log("  -> Verified: User2 (Bob) is paired.");

      // Verify getPair returns the correct pair for both users
      const user1Pair = await pairing.getPair({ user: user1 });
      assertEquals((user1Pair as { pair: ID }).pair, pairId, "User1's getPair should return the correct pair ID.");
      log("  -> User1's pair ID from getPair:", (user1Pair as { pair: ID }).pair);

      const user2Pair = await pairing.getPair({ user: user2 });
      assertEquals((user2Pair as { pair: ID }).pair, pairId, "User2's getPair should return the correct pair ID.");
      log("  -> User2's pair ID from getPair:", (user2Pair as { pair: ID }).pair);

      // 4. Either user can dissolve the pair (User1 dissolves)
      log("Step 4: User1 (Alice) dissolves the pair.");
      const dissolveResult = await pairing.dissolvePair({ pair: pairId });
      assertEquals(dissolveResult, {}, "Dissolution should return an empty object on success.");
      log("  -> Pair dissolution initiated by Alice successful.");

      // 5. Verify both users are no longer paired
      log("Step 5: Verifying both users are no longer paired after dissolution.");
      const isUser1PairedAfterDissolve = await pairing.isPaired({ user: user1 });
      assertEquals(isUser1PairedAfterDissolve, false, "User1 should not be paired after dissolution.");
      log("  -> Verified: User1 (Alice) is no longer paired.");

      const isUser2PairedAfterDissolve = await pairing.isPaired({ user: user2 });
      assertEquals(isUser2PairedAfterDissolve, false, "User2 should not be paired after dissolution.");
      log("  -> Verified: User2 (Bob) is no longer paired.");

      // getPair should now return an error for user1
      const getPairAfterDissolve = await pairing.getPair({ user: user1 });
      assertExists((getPairAfterDissolve as { error: string }).error, "getPair should return an error after dissolution.");
      assertEquals((getPairAfterDissolve as { error: string }).error.includes("not currently in an active pair"), true);
      log("  -> getPair for User1 after dissolution returns error:", (getPairAfterDissolve as { error: string }).error);

      log("Principle Test: User pairing and unpairing flow completed successfully.");
    } finally {
      await client.close();
    }
  });

  // --- Test 2.1: generateCode requirements ---
  await t.step("Action: generateCode - Requirements", async (t) => {
    await t.step("should successfully generate a code for an unpaired user", async () => {
      log("Test: generateCode - success case.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        const result = await pairing.generateCode({ user: user1 });
        assertExists((result as { code: ID }).code, "Expected a code to be returned.");
        assertEquals(typeof (result as { code: ID }).code, "string", "Returned code should be a string.");
        log("  -> Output (code):", result);
        const isPaired = await pairing.isPaired({ user: user1 });
        assertEquals(isPaired, false, "User should not be paired after just generating a code.");
        log("  -> Effects: New unique pairing code created and linked to user1. User1 is not yet paired.");
      } finally {
        await client.close();
      }
    });

    await t.step("should not allow user to generate multiple codes", async () => {
      log("Test: generateCode - user cannot generate multiple codes.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        const result1 = await pairing.generateCode({ user: user1 });
        assertExists((result1 as { code: ID }).code, "First code generation should succeed.");
        log("  -> First code generated by User1:", result1);

        const result2 = await pairing.generateCode({ user: user1 });
        assertExists((result2 as { error: string }).error, "Second attempt should return an error.");
        assertEquals((result2 as { error: string }).error.includes("has already generated a pending pairing code"), true, "Error message should indicate user has a pending code.");
        log("  -> Second attempt by User1 (expected error):", result2);
        log("  -> Requirements: User already involved in pending pairing prevents new code generation.");
      } finally {
        await client.close();
      }
    });

    await t.step("should not allow already paired user to generate code", async () => {
      log("Test: generateCode - already paired user cannot generate code.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        // Setup: Pair user1 and user2
        const code = (await pairing.generateCode({ user: user1 }) as { code: ID }).code;
        await pairing.acceptPairing({ user: user2, code: code });
        log("  -> Setup: User1 and User2 are now paired.");
        assertEquals(await pairing.isPaired({ user: user1 }), true, "User1 should be paired in setup.");

        // Attempt to generate a new code by user1 (who is already paired)
        const result = await pairing.generateCode({ user: user1 });
        assertExists((result as { error: string }).error, "Attempt by paired user to generate code should fail.");
        assertEquals((result as { error: string }).error.includes("is already in an active pair"), true, "Error message should indicate user is already paired.");
        log("  -> Attempt by User1 (already paired) to generate code (expected error):", result);
        log("  -> Requirements: User already in an active pair prevents code generation.");
      } finally {
        await client.close();
      }
    });

    await t.step("should return unique codes for different users", async () => {
      log("Test: generateCode - codes should be unique for different users.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        const result1 = await pairing.generateCode({ user: user1 });
        const code1 = (result1 as { code: ID }).code;
        log("  -> Code generated by User1:", result1);

        const result2 = await pairing.generateCode({ user: user2 });
        const code2 = (result2 as { code: ID }).code;
        log("  -> Code generated by User2:", result2);

        assertNotEquals(code1, code2, "Codes generated by different users should be unique.");
        log("  -> Effects: Unique codes returned for distinct users.");
      } finally {
        await client.close();
      }
    });
  });

  // --- Test 2.2: acceptPairing requirements ---
  await t.step("Action: acceptPairing - Requirements", async (t) => {
    await t.step("should successfully accept a valid code and form a pair", async () => {
      log("Test: acceptPairing - success case.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        const generatorResult = await pairing.generateCode({ user: user1 });
        const code = (generatorResult as { code: ID }).code;
        log("  -> Code generated by User1:", generatorResult);

        const acceptResult = await pairing.acceptPairing({ user: user2, code: code });
        assertExists((acceptResult as { pair: ID }).pair, "Expected a pair ID to be returned.");
        assertEquals(typeof (acceptResult as { pair: ID }).pair, "string", "Returned pair ID should be a string.");
        log("  -> Accept result:", acceptResult);

        assertEquals(await pairing.isPaired({ user: user1 }), true, "User1 should be paired after acceptance.");
        assertEquals(await pairing.isPaired({ user: user2 }), true, "User2 should be paired after acceptance.");
        // Verify pending code is removed (effect)
        const pendingCode = await db.collection("Pairing.pendingCodes").findOne({ _id: code });
        assertEquals(pendingCode, null, "Pending code should be removed after acceptance.");
        log("  -> Effects: New active pair created, pending code removed. Both users are now paired.");
      } finally {
        await client.close();
      }
    });

    await t.step("should not allow user to accept their own code", async () => {
      log("Test: acceptPairing - user cannot accept own code.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        const generateResult = await pairing.generateCode({ user: user1 });
        const code = (generateResult as { code: ID }).code;
        log("  -> Code generated by User1:", generateResult);

        const acceptResult = await pairing.acceptPairing({ user: user1, code: code }); // User1 trying to accept own code
        assertExists((acceptResult as { error: string }).error, "Attempt to accept own code should fail.");
        assertEquals((acceptResult as { error: string }).error.includes("cannot accept a pairing code they generated"), true, "Error message should indicate user cannot accept their own code.");
        log("  -> Attempt by User1 to accept own code (expected error):", acceptResult);

        assertEquals(await pairing.isPaired({ user: user1 }), false, "User1 should not be paired.");
        log("  -> Requirements: Acceptor cannot be the same as generator.");
      } finally {
        await client.close();
      }
    });

    await t.step("should not allow accepting invalid or already used code", async () => {
      log("Test: acceptPairing - invalid/used code.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        // Case 1: Invalid code
        const invalidCode: ID = "non-existent-code" as ID;
        const resultInvalid = await pairing.acceptPairing({ user: user2, code: invalidCode });
        assertExists((resultInvalid as { error: string }).error, "Attempt with invalid code should fail.");
        assertEquals((resultInvalid as { error: string }).error.includes("is invalid or has already been used"), true, "Error message for invalid code.");
        log("  -> Attempt with invalid code (expected error):", resultInvalid);

        // Case 2: Already used code
        const generateResult = await pairing.generateCode({ user: user1 });
        const code = (generateResult as { code: ID }).code;
        await pairing.acceptPairing({ user: user2, code: code }); // User2 uses the code
        log("  -> Setup: User1 and User2 paired with code:", code);

        const resultUsed = await pairing.acceptPairing({ user: user3, code: code }); // User3 tries to use the same code
        assertExists((resultUsed as { error: string }).error, "Attempt with used code should fail.");
        assertEquals((resultUsed as { error: string }).error.includes("is invalid or has already been used"), true, "Error message for already used code.");
        log("  -> Attempt with already used code (expected error):", resultUsed);
        log("  -> Requirements: Code must be valid and unused.");
      } finally {
        await client.close();
      }
    });

    await t.step("should not allow an already paired acceptor user to accept new code", async () => {
      log("Test: acceptPairing - already paired acceptor cannot accept new code.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        // Setup 1: Pair user1 and user2
        const code1 = (await pairing.generateCode({ user: user1 }) as { code: ID }).code;
        await pairing.acceptPairing({ user: user2, code: code1 });
        log("  -> Setup: User1 and User2 are paired.");
        assertEquals(await pairing.isPaired({ user: user2 }), true, "User2 should be paired in setup.");

        // Setup 2: User3 generates another code
        const code2 = (await pairing.generateCode({ user: user3 }) as { code: ID }).code;
        log("  -> Setup: User3 generated a new code:", code2);

        // User2 (already paired) tries to accept code2
        const result = await pairing.acceptPairing({ user: user2, code: code2 });
        assertExists((result as { error: string }).error, "Attempt by already paired acceptor should fail.");
        assertEquals((result as { error: string }).error.includes("is already in an active pair"), true, "Error message should indicate acceptor is already paired.");
        log("  -> Attempt by User2 (already paired) to accept new code (expected error):", result);
        log("  -> Requirements: Acceptor user is not already paired.");
      } finally {
        await client.close();
      }
    });

    await t.step("should not allow acceptance if generator is already paired", async () => {
      log("Test: acceptPairing - generator already paired prevents acceptance.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        // Setup 1: User1 generates code1
        const code1 = (await pairing.generateCode({ user: user1 }) as { code: ID }).code;
        log("  -> Setup: User1 generated code1:", code1);

        // Setup 2: User1 (the generator of code1) gets paired with User3 using a *different* code (code2)
        const code2 = (await pairing.generateCode({ user: user3 }) as { code: ID }).code;
        await pairing.acceptPairing({ user: user1, code: code2 }); // User1 accepts code from User3
        log("  -> Setup: User1 and User3 are paired using code2.");
        assertEquals(await pairing.isPaired({ user: user1 }), true, "User1 should be paired in setup.");

        // User2 tries to accept code1 (generated by User1, who is now paired)
        const result = await pairing.acceptPairing({ user: user2, code: code1 });
        assertExists((result as { error: string }).error, "Attempt to accept code from an already paired generator should fail.");
        assertEquals((result as { error: string }).error.includes("is already in an active pair"), true, "Error message should indicate generator is already paired.");
        log("  -> Attempt by User2 to accept code1 (generator User1 is already paired) (expected error):", result);
        log("  -> Requirements: Generator of the code is not already in an active pair.");
      } finally {
        await client.close();
      }
    });
  });

  // --- Test 2.3: dissolvePair functionality ---
  await t.step("Action: dissolvePair - Functionality", async (t) => {
    await t.step("should successfully dissolve an active pair", async () => {
      log("Test: dissolvePair - successfully dissolves an active pair.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        // Setup: Create an active pair
        const code = (await pairing.generateCode({ user: user1 }) as { code: ID }).code;
        const pairId = (await pairing.acceptPairing({ user: user2, code: code }) as { pair: ID }).pair;
        log("  -> Setup: User1 and User2 paired with ID:", pairId);
        assertEquals(await pairing.isPaired({ user: user1 }), true, "User1 should be paired in setup.");

        // Dissolve the pair
        const dissolveResult = await pairing.dissolvePair({ pair: pairId });
        assertEquals(dissolveResult, {}, "Dissolution should return an empty object on success.");
        log("  -> Dissolve result:", dissolveResult);

        // Verify users are no longer paired (effect)
        assertEquals(await pairing.isPaired({ user: user1 }), false, "User1 should not be paired after dissolution.");
        assertEquals(await pairing.isPaired({ user: user2 }), false, "User2 should not be paired after dissolution.");

        // Verify the pair document exists but is inactive (effect)
        const dissolvedPair = await db.collection("Pairing.pairs").findOne({ _id: pairId });
        assertExists(dissolvedPair, "Dissolved pair document should still exist.");
        assertEquals(dissolvedPair?.active, false, "Pair document should exist but be inactive.");
        log("  -> Effects: Pair's active status set to false. Both users are no longer paired.");
      } finally {
        await client.close();
      }
    });

    await t.step("should not allow dissolving a non-existent pair", async () => {
      log("Test: dissolvePair - non-existent pair.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        const nonExistentPairId: ID = "fake-pair-id" as ID;
        const result = await pairing.dissolvePair({ pair: nonExistentPairId });
        assertExists((result as { error: string }).error, "Attempt to dissolve non-existent pair should fail.");
        assertEquals((result as { error: string }).error.includes("does not exist or is not active"), true, "Error message for non-existent pair.");
        log("  -> Attempt to dissolve non-existent pair (expected error):", result);
        log("  -> Requirements: Pair must exist.");
      } finally {
        await client.close();
      }
    });

    await t.step("should not allow dissolving an already dissolved pair", async () => {
      log("Test: dissolvePair - already dissolved pair.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        // Setup: Create and then dissolve a pair
        const code = (await pairing.generateCode({ user: user1 }) as { code: ID }).code;
        const pairId = (await pairing.acceptPairing({ user: user2, code: code }) as { pair: ID }).pair;
        await pairing.dissolvePair({ pair: pairId });
        log("  -> Setup: Pair created and dissolved:", pairId);

        // Attempt to dissolve the same pair again
        const result = await pairing.dissolvePair({ pair: pairId });
        assertExists((result as { error: string }).error, "Attempt to dissolve already dissolved pair should fail.");
        assertEquals((result as { error: string }).error.includes("does not exist or is not active"), true, "Error message for already dissolved pair.");
        log("  -> Attempt to dissolve already dissolved pair (expected error):", result);
        log("  -> Requirements: Pair must be active.");
      } finally {
        await client.close();
      }
    });
  });

  // --- Test 2.4: getPair and isPaired queries ---
  await t.step("Action: getPair and isPaired - Queries", async (t) => {
    await t.step("getPair should return the correct pair for a user in an active pair", async () => {
      log("Test: getPair - returns correct pair for active user.");
      const [db, client] => await testDb();
      const pairing = new PairingConcept(db);
      try {
        // Setup: Create an active pair
        const code = (await pairing.generateCode({ user: user1 }) as { code: ID }).code;
        const pairId = (await pairing.acceptPairing({ user: user2, code: code }) as { pair: ID }).pair;
        log("  -> Setup: User1 and User2 paired with ID:", pairId);

        // Query for user1's pair
        const user1Pair = await pairing.getPair({ user: user1 });
        assertExists((user1Pair as { pair: ID }).pair, "getPair for user1 should return a pair ID.");
        assertEquals((user1Pair as { pair: ID }).pair, pairId, "getPair for user1 should return the correct pair ID.");
        log("  -> User1's pair:", user1Pair);

        // Query for user2's pair
        const user2Pair = await pairing.getPair({ user: user2 });
        assertExists((user2Pair as { pair: ID }).pair, "getPair for user2 should return a pair ID.");
        assertEquals((user2Pair as { pair: ID }).pair, pairId, "getPair for user2 should return the correct pair ID.");
        log("  -> User2's pair:", user2Pair);
        log("  -> Effects: Correct active pair returned for both users.");
      } finally {
        await client.close();
      }
    });

    await t.step("getPair should return an error if user is not in an active pair", async () => {
      log("Test: getPair - returns error for unpaired user.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        // User1 is not paired
        const result = await pairing.getPair({ user: user1 });
        assertExists((result as { error: string }).error, "getPair for unpaired user should return an error.");
        assertEquals((result as { error: string }).error.includes("is not currently in an active pair"), true, "Error message for unpaired user.");
        log("  -> Attempt to get pair for unpaired User1 (expected error):", result);
        log("  -> Requirements: User must be in an active pair.");
      } finally {
        await client.close();
      }
    });

    await t.step("isPaired should return true for a user in an an active pair", async () => {
      log("Test: isPaired - returns true for active user.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        // Setup: Create an active pair
        const code = (await pairing.generateCode({ user: user1 }) as { code: ID }).code;
        await pairing.acceptPairing({ user: user2, code: code });
        log("  -> Setup: User1 and User2 paired.");

        // Check isPaired for both users (effect)
        assertEquals(await pairing.isPaired({ user: user1 }), true, "User1 should be reported as paired.");
        assertEquals(await pairing.isPaired({ user: user2 }), true, "User2 should be reported as paired.");
        log("  -> isPaired for User1: true, isPaired for User2: true.");
      } finally {
        await client.close();
      }
    });

    await t.step("isPaired should return false for a user not in an active pair", async () => {
      log("Test: isPaired - returns false for unpaired user.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        // User1 is not paired
        assertEquals(await pairing.isPaired({ user: user1 }), false, "User1 should be reported as not paired.");
        log("  -> isPaired for unpaired User1: false.");

        // User3 has generated a code, but is not yet paired
        await pairing.generateCode({ user: user3 });
        assertEquals(await pairing.isPaired({ user: user3 }), false, "User3 (pending code) should not be reported as paired.");
        log("  -> isPaired for User3 (generated code): false.");
        log("  -> Effects: Correctly returns whether user is in an active pair.");
      } finally {
        await client.close();
      }
    });

    await t.step("isPaired should return false for a user whose pair was dissolved", async () => {
      log("Test: isPaired - returns false after dissolution.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        // Setup: Create and dissolve a pair
        const code = (await pairing.generateCode({ user: user1 }) as { code: ID }).code;
        const pairId = (await pairing.acceptPairing({ user: user2, code: code }) as { pair: ID }).pair;
        await pairing.dissolvePair({ pair: pairId });
        log("  -> Setup: Pair created and dissolved.");

        // Check isPaired (effect)
        assertEquals(await pairing.isPaired({ user: user1 }), false, "User1 should not be paired after dissolution.");
        assertEquals(await pairing.isPaired({ user: user2 }), false, "User2 should not be paired after dissolution.");
        log("  -> isPaired for User1 and User2 after dissolution: false.");
      } finally {
        await client.close();
      }
    });
  });

  // --- Test 2.5: Edge cases and race conditions ---
  await t.step("Edge Cases & Race Conditions", async (t) => {
    await t.step("should prevent two users from concurrently accepting the same code", async () => {
      log("Test: Concurrently accepting the same code.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        // User1 generates a code
        const generatorResult = await pairing.generateCode({ user: user1 });
        const code = (generatorResult as { code: ID }).code;
        log("  -> Code generated by User1:", code);

        // Simulate User2 and User3 trying to accept the *same* code concurrently
        const acceptPromises = [
          pairing.acceptPairing({ user: user2, code: code }),
          pairing.acceptPairing({ user: user3, code: code }),
        ];

        const results = await Promise.all(acceptPromises);
        log("  -> Results of concurrent accept attempts:", results);

        // Exactly one should succeed, the other should fail due to the code being used.
        let successCount = 0;
        let errorCount = 0;
        let successfulPairId: ID | undefined;
        let successfulAcceptor: ID | undefined;

        for (let i = 0; i < results.length; i++) {
          const res = results[i];
          const acceptor = (i === 0) ? user2 : user3;
          if ((res as { pair: ID }).pair) {
            successCount++;
            successfulPairId = (res as { pair: ID }).pair;
            successfulAcceptor = acceptor;
          } else if ((res as { error: string }).error) {
            errorCount++;
            assertEquals((res as { error: string }).error.includes("is invalid or has already been used") || (res as { error: string }).error.includes("Failed to create pair due to a conflict"), true, `Error message for failed concurrent accept by ${acceptor}`);
          }
        }

        assertEquals(successCount, 1, "Exactly one acceptance should succeed.");
        assertEquals(errorCount, 1, "Exactly one acceptance should fail with an error.");
        assertExists(successfulPairId, "A pair ID should have been created.");
        assertExists(successfulAcceptor, "A successful acceptor should be identified.");

        // Verify the successful pair exists and involves the generator (user1) and the successful acceptor
        const createdPair = await db.collection("Pairing.pairs").findOne({ _id: successfulPairId });
        assertExists(createdPair, "The created pair document should exist.");
        assertEquals(createdPair?.active, true, "The created pair should be active.");
        assertEquals(createdPair?.user1, user1, "The generator should be user1.");
        assertEquals(createdPair?.user2, successfulAcceptor, "The acceptor should be the successful one.");

        // Verify the generator (user1) and the successful acceptor are paired
        assertEquals(await pairing.isPaired({ user: user1 }), true, "User1 (generator) should be paired.");
        assertEquals(await pairing.isPaired({ user: successfulAcceptor as ID }), true, "Successful acceptor should be paired.");
        // Verify the unsuccessful acceptor is not paired
        const unsuccessfulAcceptor = (successfulAcceptor === user2) ? user3 : user2;
        assertEquals(await pairing.isPaired({ user: unsuccessfulAcceptor as ID }), false, "Unsuccessful acceptor should not be paired.");
        log("  -> Effects: Only one pair is formed, the pending code is consumed. All requirements satisfied.");
      } finally {
        await client.close();
      }
    });

    await t.step("should prevent a user from being paired twice if they generated a code and another user accepts it while they are also trying to accept another code", async () => {
      log("Test: Generator getting paired while trying to accept another code.");
      const [db, client] = await testDb();
      const pairing = new PairingConcept(db);
      try {
        // User1 generates codeA
        const codeA = (await pairing.generateCode({ user: user1 }) as { code: ID }).code;
        log("  -> User1 generated codeA:", codeA);

        // User3 generates codeB
        const codeB = (await pairing.generateCode({ user: user3 }) as { code: ID }).code;
        log("  -> User3 generated codeB:", codeB);

        // Simulate:
        // User2 accepts codeA (User1 becomes paired as generator)
        // Concurrently, User1 tries to accept codeB (which User3 generated)
        const [user2AcceptResult, user1AcceptResult] = await Promise.all([
          pairing.acceptPairing({ user: user2, code: codeA }), // This should make User1 paired (as generator)
          pairing.acceptPairing({ user: user1, code: codeB }), // This should fail as User1 becomes paired
        ]);
        log("  -> Results of concurrent accept attempts (User2 accepts codeA, User1 accepts codeB):", { user2AcceptResult, user1AcceptResult });

        // User2 accepting codeA should succeed, making User1 paired
        assertExists((user2AcceptResult as { pair: ID }).pair, "User2's acceptance of codeA should succeed.");
        assertEquals(await pairing.isPaired({ user: user1 }), true, "User1 should be paired as a generator via codeA.");
        assertEquals(await pairing.isPaired({ user: user2 }), true, "User2 should be paired as an acceptor via codeA.");
        log("  -> Verified: User1 and User2 are paired via codeA.");

        // User1 trying to accept codeB should fail because User1 is now paired
        assertExists((user1AcceptResult as { error: string }).error, "User1's attempt to accept codeB should fail.");
        assertEquals((user1AcceptResult as { error: string }).error.includes("is already in an active pair"), true, "Error should indicate User1 is already paired (as acceptor).");
        log("  -> Verified: User1's attempt to accept codeB failed because they are already paired with User2.");

        // User3 should not be paired (their codeB was not successfully accepted)
        assertEquals(await pairing.isPaired({ user: user3 }), false, "User3 should not be paired.");
        log("  -> Verified: User3 is not paired.");
        log("  -> Requirements: User cannot be paired if already in an active pair, whether as generator or acceptor. State consistency maintained.");
      } finally {
        await client.close();
      }
    });
  });
});

```