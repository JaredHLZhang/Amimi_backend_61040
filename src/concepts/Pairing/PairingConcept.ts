import { Collection, Db } from "npm:mongodb";
import { ID, Empty } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";
import { v4 as uuidv4 } from "npm:uuid"; // For generating unique codes

/**
 * concept: Pairing [User]
 *
 * purpose: Enable users to form exclusive partnerships through a code-based pairing mechanism
 *
 * principle: When one user generates a pairing code and shares it with another user,
 * and that user enters the code, the two users become paired;
 * the pair can be dissolved later if needed
 */
const PREFIX = "Pairing" + ".";

// Generic type parameters for this concept
type User = ID;
type PairId = ID; // Identifier for a Pair document
type PairingCode = ID; // Identifier for a pending code, or the code within a Pair

/**
 * Represents a temporary pairing code generated by a user,
 * waiting for another user to accept it.
 * The _id of this document is the pairing code itself.
 */
interface PendingPairingCode {
  _id: PairingCode; // The unique code string
  generatorUser: User;
  createdAt: Date;
}

/**
 * Represents an exclusive partnership between two users,
 * formed using a pairing code.
 */
interface PairDocument {
  _id: PairId; // Unique ID for the pair document
  user1: User; // The user who generated the pairing code
  user2: User; // The user who accepted the pairing code
  code: PairingCode; // The specific code used to form this pairing
  active: boolean; // True if the pair is currently active, false if dissolved
  createdAt: Date; // Timestamp when the pair was created
  sharedConversationId?: string; // Optional ID for the shared group conversation
}

export default class PairingConcept {
  private pairs: Collection<PairDocument>;
  private pendingCodes: Collection<PendingPairingCode>;

  constructor(private readonly db: Db) {
    this.pairs = this.db.collection(PREFIX + "pairs");
    this.pendingCodes = this.db.collection(PREFIX + "pendingCodes");
    
    // Note: Indexes are not created in constructor to avoid hanging promises.
    // Uniqueness constraints are enforced through application logic and MongoDB duplicate key errors.
  }

  /**
   * generateCode (user: User): (code: String)
   *
   * **requires**:
   *   - `user` is a valid ID string (validation is external to this concept).
   *   - `user` is not already involved in a pending pairing process.
   *   - `user` is not already in an active pair.
   *
   * **effects**: Creates a new unique pairing code linked to this user and returns it.
   */
  async generateCode({ user }: { user: User }): Promise<{ code: PairingCode } | { error: string }> {
    // Check if the user is already involved in a pending code generation
    const existingPendingCode = await this.pendingCodes.findOne({ generatorUser: user });
    if (existingPendingCode) {
      return { error: `User ${user} has already generated a pending pairing code (${existingPendingCode._id}). Please use that or dissolve it first.` };
    }

    // Check if the user is already in an active pair
    const existingActivePair = await this.pairs.findOne({ $or: [{ user1: user }, { user2: user }], active: true });
    if (existingActivePair) {
      return { error: `User ${user} is already in an active pair (${existingActivePair._id}). Dissolve it to generate a new code.` };
    }

    // Generate a unique code (UUIDs are highly unlikely to collide)
    const newCode: PairingCode = uuidv4() as PairingCode;

    const doc: PendingPairingCode = {
      _id: newCode,
      generatorUser: user,
      createdAt: new Date(),
    };

    try {
      await this.pendingCodes.insertOne(doc);
      return { code: newCode };
    } catch (e: any) {
      // Catch potential, though very rare, duplicate _id if uuidv4() somehow repeats or a database issue occurs.
      if (e.code === 11000) { // MongoDB duplicate key error
        return { error: `Failed to generate a unique pairing code (duplicate ID). Please try again.` };
      }
      return { error: `Database error during code generation: ${e.message}` };
    }
  }

  /**
   * acceptPairing (user: User, code: String): (pair: Pair)
   *
   * **requires**:
   *   - `code` is valid and currently unused (exists as a pending code).
   *   - `user` (the acceptor) is not the same as the user who generated the `code`.
   *   - `user` (the acceptor) is not already in an active pair.
   *   - The generator of the `code` is not already in an active pair.
   *
   * **effects**: Creates a new active pair linking the two users, and removes the pending code.
   *              Returns the ID of the newly created pair.
   */
  async acceptPairing({ user, code }: { user: User; code: PairingCode }): Promise<{ pair: PairId } | { error: string }> {
    // 1. Validate the pairing code and retrieve its generator
    const pendingCode = await this.pendingCodes.findOne({ _id: code });
    if (!pendingCode) {
      return { error: `Pairing code ${code} is invalid or has already been used.` };
    }
    const generatorUser = pendingCode.generatorUser;

    // 2. Ensure the acceptor is not the generator
    if (user === generatorUser) {
      return { error: `User ${user} cannot accept a pairing code they generated.` };
    }

    // 3. Check if the acceptor user is already in an active pair
    const acceptorExistingPair = await this.pairs.findOne({ $or: [{ user1: user }, { user2: user }], active: true });
    if (acceptorExistingPair) {
      return { error: `User ${user} is already in an active pair (${acceptorExistingPair._id}). Dissolve it to accept a new pairing.` };
    }

    // 4. Check if the generator user is already in an active pair
    // This is crucial to maintain exclusivity if the generator user created multiple codes
    const generatorExistingPair = await this.pairs.findOne({ $or: [{ user1: generatorUser }, { user2: generatorUser }], active: true });
    if (generatorExistingPair) {
      return { error: `The generator of code ${code} (${generatorUser}) is already in an active pair (${generatorExistingPair._id}).` };
    }

    // Create the new pair document
    const newPairId: PairId = freshID() as PairId;
    const newPair: PairDocument = {
      _id: newPairId,
      user1: generatorUser,
      user2: user,
      code: code,
      active: true,
      createdAt: new Date(),
    };

    try {
      // Atomically insert the new pair and remove the pending code
      await this.pairs.insertOne(newPair);
      await this.pendingCodes.deleteOne({ _id: code });
      
      // Create shared group conversation for the paired users
      try {
        const GroupConversationConcept = (await import("../GroupConversation/GroupConversationConcept.ts")).default;
        const groupConcept = new GroupConversationConcept(this.db);
        const createConversationResult = await groupConcept.createGroupConversation({
          participants: [generatorUser, user],
          context: "Long-distance couple seeking relationship support and connection"
        });
        
        if (createConversationResult.status === 'success') {
          // Update the pair document with shared conversation ID
          await this.pairs.updateOne(
            { _id: newPairId },
            { $set: { sharedConversationId: createConversationResult.conversation.conversationId } }
          );
          console.log(`Created shared conversation ${createConversationResult.conversation.conversationId} for pair ${newPairId}`);
        }
      } catch (syncError) {
        console.error('Failed to create shared conversation during pairing:', syncError);
        // Don't fail the pairing if conversation creation fails
      }
      
      return { pair: newPairId };
    } catch (e: any) {
      // Handle potential race conditions where unique constraints might be violated
      if (e.code === 11000) { // MongoDB duplicate key error
        // This could happen if, for example, two users try to accept the same code concurrently,
        // or if a user concurrently accepts two different codes.
        return { error: `Failed to create pair due to a conflict (e.g., user already paired, or code already used). Please try again.` };
      }
      return { error: `Database error during pairing acceptance: ${e.message}` };
    }
  }

  /**
   * dissolvePair (pair: Pair)
   *
   * **requires**:
   *   - `pair` exists and is currently active.
   *
   * **effects**: Sets the `active` status of the specified pair to `false`.
   */
  async dissolvePair({ pair }: { pair: PairId }): Promise<Empty | { error: string }> {
    // Verify that the pair exists and is currently active
    const existingPair = await this.pairs.findOne({ _id: pair, active: true });
    if (!existingPair) {
      return { error: `Pair ${pair} does not exist or is not active.` };
    }

    // Update the pair's status to inactive
    const result = await this.pairs.updateOne(
      { _id: pair },
      { $set: { active: false } }
    );

    if (result.matchedCount === 0) {
      // This should ideally not happen if findOne above was successful, but a defensive check
      return { error: `Failed to find pair ${pair} for dissolution.` };
    }
    if (result.modifiedCount === 0) {
      // This indicates the pair was found but its 'active' status wasn't changed.
      // Could imply a race condition where it became inactive just before update, or logical error.
      return { error: `Pair ${pair} was found but its active status was not modified (possibly already dissolved).` };
    }

    return {}; // Return empty object for successful operation
  }

  /**
   * getPair (user: User): (pair: Pair)
   *
   * **requires**:
   *   - `user` is currently in an active pair.
   *
   * **effects**: Returns the ID of the active pair that includes the specified user.
   */
  async getPair({ user }: { user: User }): Promise<{ pair: PairId; sharedConversationId?: string; partner: User } | { error: string }> {
    // Find an active pair where the user is either user1 or user2
    const activePair = await this.pairs.findOne({ $or: [{ user1: user }, { user2: user }], active: true });

    if (!activePair) {
      return { error: `User ${user} is not currently in an active pair.` };
    }

    // Determine partner's ID
    const partner = activePair.user1 === user ? activePair.user2 : activePair.user1;

    return { 
      pair: activePair._id,
      sharedConversationId: activePair.sharedConversationId,
      partner: partner
    };
  }

  /**
   * isPaired (user: User): (Boolean)
   *
   * **effects**: Returns `true` if the specified `user` is currently in an active pair, `false` otherwise.
   */
  async isPaired({ user }: { user: User }): Promise<boolean> {
    // Check for the existence of an active pair involving the user
    const activePair = await this.pairs.findOne({ $or: [{ user1: user }, { user2: user }], active: true });
    return !!activePair; // Convert truthiness to boolean
  }
}

